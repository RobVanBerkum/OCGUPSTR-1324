import * as fs from 'fs'
import * as path from 'path'
import * as chokidar from 'chokidar'
import * as moment from 'moment'
import { 
	TaskType, 
	TaskInput, TaskOutput, 
	TaskTypeOptionsFolderWatch, TaskInputFolderWatch, TaskOutputFolderWatch, TaskInputGenperl
} from './../messages'
import { IClient } from './../clients'
import { Task } from './base'


/** Task implementation for FolderWatch. */
export class TaskFolderWatch extends Task<TaskInputFolderWatch, TaskOutputFolderWatch> {
	private watchPath = path.resolve(this.input.watchPath)
	private watcher: chokidar.FSWatcher
	private createTaskCallback: (type: TaskType, input: TaskInput) => Task<TaskInput, TaskOutput>
	type: TaskType = 'FolderWatch'

	/** Get task type options. */
	static getTaskTypeOptions = (): TaskTypeOptionsFolderWatch => {
		const propertyKeyGenperl: keyof TaskInputGenperl = 'pathGendsc'
		return { 
			fileHandlers: ['GenperlStartfileHandler', 'TriggerTaskHandler'], 
			triggerTasks: [{type: 'Genperl', propertyKey: propertyKeyGenperl}]
		}
	}

	/** Handle detected start file. */
	private handleStartfile = (filePath: string) => {

		// Parse genperl command. Supported args are: 
		//   'dynamo'                
		//   'dynamo_development|ddev
		//   'dynamo_version|d=s'    
		//   'input_file|f=s'        
		//   'genrem_debug|debug'    
		//   'genrem_development|dev'
		//   'genrem_version|g=s'    
		//   'priority|prio'         
		//   'run_local|loc'         
		//   'help|h|?'              
		//   'list_versions|l'       
		//   'max_threads|t=i'       
		const cmdToGenperlInput = (cmd: string) => {    
			let parts = cmd
				.match(/("[^"]+"|[^"\s]+)/g)   // Split in parts that are quoted or surrounded by spaces.
				.map(v => v.replace(/['"]+/g, ''))   // Remove quotes from all parts. 
			let iDynamo = parts.findIndex(v => v == '-dynamo')
			let iDynamoDevelopment = parts.findIndex(v => v == '-dynamo_development' || v == '-ddev')
			let iDynamoVersion = parts.findIndex(v => v == '-dynamo_version' || v == '-d')
			let iInputFile = parts.findIndex(v => v == '-input_file' || v == '-f')
			let iGenremDebug = parts.findIndex(v => v == '-genrem_debug' || v == '-debug')
			let iGenremDevelopment = parts.findIndex(v => v == '-genrem_development' || v == '-dev')
			let iGenremVersion = parts.findIndex(v => v == '-genrem_version' || v == '-g')
			let iPriority = parts.findIndex(v => v == '-priority' || v == '-prio')
			let iRunLocal = parts.findIndex(v => v == '-run_local' || v == '-loc')
			let input: TaskInputGenperl = {
				description: `Generated by TaskFolderWatch (${this.id}).`,
				pathGendsc: iInputFile >= 0 ? parts[iInputFile + 1] : '', 
				runLocal: iRunLocal >= 0, 
				useDynamo: iDynamo >= 0, 
				useGensimulDev: iGenremDevelopment >= 0, 
				useDynamoDev: iDynamoDevelopment >= 0, 
				gensimulVersion: iGenremVersion >= 0 ? parts[iGenremVersion + 1] : '',
				dynamoVersion: iDynamoVersion >= 0 ? parts[iDynamoVersion + 1] : ''
			}
			return input
		}

		this.addLogItem({type: 'Info', date: moment().toISOString(), text: `New file detected '${path.basename(filePath)}', parsing startfile.`})
		let lines = fs.readFileSync(filePath).toString().split('\n')
		lines.map(line => line.trim()).filter(line => line != '').forEach(cmd => {
			try {
				let input = cmdToGenperlInput(cmd)
				let task = this.createTaskCallback('Genperl', input)
				task.start()
				this.output.triggeredTasks.push({taskId: task.id, filePath: filePath, taskType: 'Genperl'})
				this.addLogItem({type: 'Info', date: moment().toISOString(), text: `Added task Genperl with id ${task.id}.`})
			} catch (err) {
				let errText = (err as Error).message
				this.addLogItem({type: 'Warning', date: moment().toISOString(), text: `Failed to start Genperl using cmd '${cmd}': ${errText}`})
			}
		})
		this.addLogItem({type: 'Info', date: moment().toISOString(), text: `Finished parsing startfile.`})
	}

	/** Handle detected file via trigger task. */
	private handleTriggertask = (filePath: string) => {
		let type = this.input.triggerTaskType
		this.addLogItem({type: 'Info', date: moment().toISOString(), text: `New file detected '${path.basename(filePath)}', triggering task type ${type}.`})
		let description = `Generated by TaskFolderWatch (${this.id}).`
		let input = {...this.input.triggerTaskInput, [this.input.triggerTaskPropertyKey]: filePath, description: description}
		try {
			let task = this.createTaskCallback(type, input)
			task.start()
			this.output.triggeredTasks.push({filePath: filePath, taskType: type, taskId: task.id})
		} catch(err) {
			let errText = (err as Error).message
			this.addLogItem({type: 'Warning', date: moment().toISOString(), text: `Failed to start task type ${type}: ${errText}`})
		}
	}

	/** Handle add event of file watcher. */
	private handleAdd = async (filePath: string) => {
		let fileHandler = this.input.fileHandler
		switch (fileHandler) {
			case 'GenperlStartfileHandler' : 
				this.handleStartfile(filePath)
				break
			case 'TriggerTaskHandler' : 
				this.handleTriggertask(filePath)
				break
			default : 
				this.handleError(`File handler ${fileHandler} not implemented.`)
		}
	}

	/** Handle error event of file watcher. */
	private handleError = (error: string) => {
		this.addLogItem({type: 'Error', date: moment().toISOString(), text: `Error in file watcher: ${error}`})
		if (this.watcher) {
			this.watcher.close()
		}
		this.setStatus('Error')
	}

	/** Default constructor. Pass function to be called for creating new tasks based on detected files. */
	constructor(owner: IClient, input: TaskInputFolderWatch, createTaskCallback: (type: TaskType, input: TaskInput) => Task<TaskInput, TaskOutput>) {
		super(owner, input)
		this.createTaskCallback = createTaskCallback
		this.output = {triggeredTasks: []}
	}

	/** Start this task. */
	start = async () => {
		this.output = {triggeredTasks: []}
		this.setStatus('Running')

		if (fs.existsSync(this.watchPath)) {
			this.watcher = chokidar.watch(this.watchPath, {
				ignored: /(^|[\/\\])\../,   // mentioned in chokidar documentation as typical use, but not sure we need it here
				ignoreInitial: true,
	  			persistent: true,
	  			usePolling: true,
				interval: 100,
				alwaysStat: false,
				depth: 1,
				awaitWriteFinish: {
					stabilityThreshold: 2000,
					pollInterval: 100
				},
			})
			this.watcher.on('add', this.handleAdd)
			this.watcher.on('error', this.handleError)
			this.addLogItem({type: 'Info', date: moment().toISOString(), text: `Watching folder: ${this.watchPath}`})
		} else {
			this.addLogItem({type: 'Error', date: moment().toISOString(), text: `Failed to start, path ${this.watchPath} does not exist.`})
			this.setStatus('Error')
		}
	}

	/** Stop this task. */
	stop = async () => {
		this.addLogItem({date: moment().toISOString(), type: 'Info', text: 'User requested to stop task.'})
		this.setStatus('PendingStop')
		if (this.watcher) {
			this.watcher.close()
		}
		this.addLogItem({date: moment().toISOString(), type: 'Info', text: 'Task stopped successfully.'})
		this.setStatus('Success')
	}
}